import requests
from web3 import Web3
import os #environment varibales stored


# Evtll unterschiedliche Tokenamounts für average or current
host= "http://127.0.0.1:8030/" # rest api
#host = "http://132.199.123.229:8765"
rpi2_address = "0xD793b7d81B580b66E5934B95fA0cc3965e3c505F" #rpi 1 address

#rpi2__sk = os.environ.get('RPI1__sk')

rpi2__sk = "d446243799ed98867ad7a013a8fb212710a432ab39a2f2186aae495c49cf365e"

# Connect web3 to the Infura node (Rinkeby Network)
infura_url = "https://rinkeby.infura.io/v3/3423f6258c3b46e98459616f589e4300"
web3 = Web3(Web3.HTTPProvider(infura_url))

gasLimit = 21000
#gasPrice = web3.toWei('40', 'gwei') # muss noch konvertiert werden
gasPrice =  web3.toWei(gasLimit, 'ether'),

gas =float('.'.join(str(elem) for elem in gasPrice))
#print(gas)

# Request the transaction info to send tokens
response = requests.get(host + "transaction/data")


# Get the body of the response of rpi2 (TransactionInfo)
transactionInfo = response.json()
rpi1_address = str(transactionInfo['rpi1_address'])
tokenAmount =  str(transactionInfo['tokenAmount'])

# TEST:
#print(rpi1_address)
#print(tokenAmount)

# Method to request the current balance
def getBalance(address):
    balance = web3.eth.getBalance(address)
    convertedBalance = web3.fromWei(balance, 'ether') # ether 18 decimals convert balance
    return convertedBalance

# TEST:
#currentBalance = getBalance(rpi2_address)
#print(currentBalance)

# Method to verify the transaction
def verifyTransaction(rpi1_address, rpi2_address, tokenAmount):
    currentBalance = getBalance(rpi2_address) # Get current balance of rpi1
    # Check if the balance of rpi1 is enough <= (token + gasPrice)
    if(float(currentBalance) < (float(tokenAmount) + 0.00000002)): #gas müsste jz nochmal konvertiert werden da er 51000 max ist
        return "Not enough tokens for transaction. Please buy more token."  # noch kein akkurater gasprice
    else:
        tx = createTx(rpi1_address, tokenAmount, rpi2_address)
        return tx

# Create the transaction and return the created tx
def createTx(rpi1_address, tokenAmount, rpi2_address):
    nonce= web3.eth.getTransactionCount(rpi2_address)

    tx = {
    'nonce': nonce,
    'to': rpi1_address,
    'value': web3.toWei(tokenAmount, 'ether'),
    'gas': 50000, # max tokenAmount of gas price you are willing to pay for tx #21000 war zu langsam und ging ned
    'gasPrice': web3.toWei('60', 'gwei'), # gasprice we actually send to send tx
}
    return tx

createdTx = verifyTransaction(rpi1_address, rpi2_address, tokenAmount)

# Sign the transaction with private key of rpi1
def signTransaction(tx, _sk):
    signedTx = web3.eth.account.signTransaction(tx, _sk) #why only _sk
    return signedTx

signedTx = signTransaction(createdTx, rpi2__sk)

# Method sends transaction
def sendTx(signedTx):
    sentTx = web3.eth.sendRawTransaction(signedTx.rawTransaction)
    return sentTx

sentTx = sendTx(signedTx)

# Returns the hashKey of sent transaction -> Hashkey is a confirmation of a successful transaction
def getHash(sentTx):
    hashKey = web3.toHex(sentTx)
    return hashKey

transactionHash = getHash(sentTx)

print(transactionHash)

# Send the transactionHash and address of RPi1 through a header
request_params= {'transactionHash': transactionHash, 'rpi2_address': rpi2_address}
data_request = requests.get(host + "data/average/temperature", params=request_params)

responseValues = data_request.json()
value = responseValues['value']
print(value)

