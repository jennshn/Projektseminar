from flask import Flask, request, redirect
from flask.helpers import make_response, url_for
import requests
#from influxdb import InfluxDBClient
from flask_restful import Api, Resource, reqparse
from web3 import Web3
from time import sleep # error cuz to many requests sleep(seconds)
from requests.exceptions import ConnectionError # handle connection error
import os #env var stored 
# in env variablen (damit es nicht in url ersichtlich ist) auf Linux ubuntu (rpi) auch erstellen


app = Flask(__name__)


# TO DO:
# HTTPS implementieren -> DONE in Webserver jetzt nur noch mit Client verbinden
# GENERATE PUBLIC KEY AND PRIVATE KEY ON CLIENTSIDE und senden (dann damit Cipher verschlüsseln und zurücksenden)
# Host/Port aufspalten in Var -> NO sag ich
# tokenAmount umwandeln
# Umbennen von den Variablen (RPI1 & RPI2 vertauschen) --> DONE
# Dokumentation
# Environment Variablen umbenennen / müssen eh neu installiert werden auf RPI
# Ganache mit Infura erneuern -> DONE
# Aussagekräftigere Namen -> DONE
# Evtll wenn ein Error ist Verbindung abbrechen
# bei Sessions könnte man hinzufügen, wenn jemand zu wenig Tokens gesendet hat wv noch gesendet werden müssen ?
# Funktion auslagern -> DONE
# Funktion getHash auslagern -> DONE
# Sagen welche Value man haben will, requestedValue beinflusst dann welche Daten man zurückkriegt -> DONE
# getHumditiy auslagern -> DONE

# Build a REST api for Raspberry Pi 2, so rpi2 can handle specific requests
# Hinzufügen: Statuscodes
app = Flask(__name__)
api = Api(app)

#print(os.environ) prints all env vars
# Sensitive Data

#user = "prosem"
#password = "prosem21kp"

user = os.environ.get('RPI2_USER')
password = os.environ.get('RPI2_PASSWORD')

#data_request_args = reqparse.RequestParser()
#data_request_args.add_argument('text', location = ['headers']) #not case-sensitive anymore


# Connect web3 to the Infura node (Rinkeby Network)
infura_url = "https://rinkeby.infura.io/v3/3423f6258c3b46e98459616f589e4300"
web3 = Web3(Web3.HTTPProvider(infura_url))

# Endpoint to request sensordata from raspberry pi2
sensor_url = "http://132.199.123.229:54683/query" #Better url building!!

rpi1_address = "0x839a21ccdF3c54EA69C2eAAd942073568172cCE9" # rpi1 wallet address
tokenAmount = 0.01

# To verify the transaction of rpi1 we need to get the balance of rpi2 (so we can send sensordata)
def getBalance(address):
    balance = web3.eth.getBalance(address)
    convertedBalance = web3.fromWei(balance, 'ether') # ether 18 decimals convert balance
    return convertedBalance

rpi1_balance = getBalance(rpi1_address) #NEW

# Verify the transaction
def verifyTransaction(addressFrom, addressTo, transactionFrom, transactionTo, currentBalance, balanceBefore, tokenAmount):
    if (float(currentBalance) >= (float(balanceBefore) + float(tokenAmount))
        and (transactionTo == addressTo)
        and (transactionFrom == addressFrom)):
        return True


#transactionInfo = {"rpi1_address": rpi1_address, "tokenAmount": tokenAmount} #change to rpi1_address and vice vervca

# Create a Resource to handle requests and return the transaction info: rpi2 address and token amount
class TransactionData(Resource):
    def get(self):
        transactionInfo = {"rpi1_address": rpi1_address, "tokenAmount": tokenAmount}
        return transactionInfo


# Add the Resource Transaction Info to our REST Api
api.add_resource(TransactionData, '/transaction/data')

print(rpi1_balance)

#rpi2_pk = request.args['rpi2_pk']
#print("PublicKey of rpi2 : " + rpi2_pk)

# Handles the data request after the transaction
class SensorDataRequest(Resource):
    def get(self, measurement, type):
        global key
        global rpi1_balance
        sleep(15)
        currentBalance = getBalance(rpi1_address)
        print(currentBalance)
        transactionHash = request.args['transactionHash']
        rpi2_address = request.args['rpi2_address']

        hashInfo = web3.eth.getTransaction(transactionHash) # Test if it is a valid hash
        txFrom = hashInfo.get('from')
        txTo = hashInfo.get('to')

        if(verifyTransaction(rpi2_address, rpi1_address, txFrom, txTo, currentBalance, rpi1_balance, tokenAmount)):
            if(measurement == 'temperature' and type == "current"):
                currentTemp = getTemperature()
                jsonResponse = {'value': str(currentTemp)}
                return make_response(jsonResponse)

            elif(measurement == 'humidity' and type == "current"):
                currentHumidity = getHumidity()
                print(currentHumidity)
                jsonResponse = {'value': str(currentHumidity)}
                return make_response(jsonResponse)

            elif(measurement == 'temperature' and type == 'average'):
                temperatureMean = getTemperatureMean()
                jsonResponse = {'value': str(temperatureMean)}
                return make_response(jsonResponse)

            elif(measurement == 'humidity' and type == 'average'):
                humidityMean = getHumidityMean()
                jsonResponse = {'value': str(humidityMean)}
                return make_response(jsonResponse)

        else:
            return print("Not enough token sent!")

# Add the Resource Data Request to our REST Api
api.add_resource(SensorDataRequest, '/data/<string:type>/<string:measurement>/', endpoint="data")

rpi1_balance = getBalance(rpi1_address) #innerhalb der Ressource Data aktualisieren?

# Following methods send a HTTP GET requests to the database of rpi1 at the endpoint /query
# Get the current temperature
def getTemperature():
    i=0
    while i <30:
        try:
            query ='SELECT \"temperature\" FROM \"sensor_data\".\"autogen\".\"mqtt_consumer\" WHERE \"time\" > now() -10d'
            url_params={'pretty': True, 'db':'sensor_data', 'q':query}
            r = requests.get(sensor_url, auth=(user, password), params=url_params).json()
            currentTemp = r['results'][0]['series'][0]['values'][-1][1] #get the current temperature without time
            #ba = bytearray(struct.pack("f", currentTemp))  #Convert float to bytes
            #encrypted_text = cipher.encrypt(bytes(ba))
            #pay = json.dumps({'picture' : data.encode('base64')})
            print(currentTemp)
            return currentTemp #Object of type bytes is not JSON serializable

        except requests.ConnectionError:
            sleep(1)
            i+=1
            return print("Not found")

# Get the current humidity
def getHumidity():
    try:
        query = 'SELECT \"humidity\" FROM \"sensor_data\".\"autogen\".\"mqtt_consumer\" WHERE \"time\" > now() - 20d'
        url_params = {'pretty': True, 'db':'sensor_data', 'q':query}
        h = requests.get(sensor_url, auth=(user, password), params=url_params).json()
        currentHumidity = h['results'][0]['series'][0]['values'][-1][1] #get the current humidity
        print(currentHumidity)
        return currentHumidity

    except requests.ConnectionError:
        return print("Not found")

# Get the average temperature of today
def getTemperatureMean():
    query = 'SELECT mean(\"temperature\") AS \"mean_humidity\" FROM \"sensor_data\".\"autogen\".\"mqtt_consumer\" WHERE \"time\" > now() - 1d'
    url_params = {'pretty': True, 'db':'sensor_data', 'q':query}
    h = requests.get(sensor_url, auth=(user, password), params=url_params).json()
    tempMeanToday = h['results'][0]['series'][0]['values'][-1][1] #get the temp average of today
    #return str(round(tempMeanToday, 2))+" °C"
    return tempMeanToday

# Get the average humidty of today
def getHumidityMean():
    try:
        query = 'SELECT mean(\"humidity\") AS \"mean_humidity\" FROM \"sensor_data\".\"autogen\".\"mqtt_consumer\" WHERE \"time\" > now() - 1d'
        url_params = {'pretty': True, 'db':'sensor_data', 'q':query}
        h = requests.get(sensor_url, auth=(user, password), params=url_params).json()
        humidityMeanToday = h['results'][0]['series'][0]['values'][-1][1] #get the hum average of today
        #return str(round(humidityMeanToday, 2))+" %"
        return humidityMeanToday

    except requests.ConnectionError:
        return print("Not found")

# This route lists all available ressources and methods in JSON-format
@app.route('/') # Maybe add a GET
def routes():
   routes = []
   for route in app.url_map.iter_rules():
    routes.append('%s' % route)
    return{'routes': routes}


if __name__ == '__main__':
    app.run(port=8030, debug =True) # Run the app on localhost:8030
    #Am Ende debug auf false setzen
